// auth.js
// CONFIG — replace with your real values
const cognitoDomain = "https://us-east-1e3ijnkrbr.auth.us-east-1.amazoncognito.com";
const clientId = "2g3lh5n8te1sv4vccl2veku57t";
const redirectUri = "https://d166hi15epg4f7.cloudfront.net"; // must exactly match Cognito callback URL
const logoutUri = "https://d166hi15epg4f7.cloudfront.net";   // must exactly match Cognito sign-out URL
const tokenStorageKey = "cognito_tokens";
const pkceVerifierKey = "pkce_verifier";

// --- PKCE helpers ---
function generateCodeVerifier() {
  const array = new Uint8Array(64);
  window.crypto.getRandomValues(array);
  return Array.from(array, dec => ('0' + dec.toString(16)).slice(-2)).join('');
}

async function generateCodeChallenge(verifier) {
  const encoder = new TextEncoder();
  const data = encoder.encode(verifier);
  const digest = await window.crypto.subtle.digest("SHA-256", data);
  const base64 = btoa(String.fromCharCode(...new Uint8Array(digest)));
  return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}

// --- Redirect helpers ---
async function redirectToLogin() {
  const verifier = generateCodeVerifier();
  localStorage.setItem(pkceVerifierKey, verifier);
  const challenge = await generateCodeChallenge(verifier);

  const loginUrl = `${cognitoDomain}/login`
    + `?client_id=${encodeURIComponent(clientId)}`
    + `&response_type=code`
    + `&scope=${encodeURIComponent("openid email phone")}`
    + `&redirect_uri=${encodeURIComponent(redirectUri)}`
    + `&code_challenge_method=S256`
    + `&code_challenge=${encodeURIComponent(challenge)}`;

  window.location.href = loginUrl;
}

function redirectToLogout() {
  // clear local tokens first
  localStorage.removeItem(tokenStorageKey);
  localStorage.removeItem(pkceVerifierKey);

  const logoutUrl = `${cognitoDomain}/logout`
    + `?client_id=${encodeURIComponent(clientId)}`
    + `&logout_uri=${encodeURIComponent(logoutUri)}`;

  window.location.href = logoutUrl;
}

// --- Exchange code for tokens (Authorization Code flow) ---
async function exchangeCodeForTokens(code) {
  const verifier = localStorage.getItem(pkceVerifierKey);
  if (!verifier) {
    console.error("No PKCE verifier available; redirecting to login.");
    redirectToLogin();
    return null;
  }

  const tokenUrl = `${cognitoDomain}/oauth2/token`;
  const body = new URLSearchParams({
    grant_type: "authorization_code",
    client_id: clientId,
    code,
    redirect_uri: redirectUri,
    code_verifier: verifier
  });

  const res = await fetch(tokenUrl, {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: body.toString()
  });

  if (!res.ok) {
    const text = await res.text().catch(() => "");
    console.error("Token exchange failed:", res.status, text);
    return null;
  }

  const tokens = await res.json();
  // tokens: access_token, id_token, expires_in (seconds), optional refresh_token
  const now = Math.floor(Date.now() / 1000);
  tokens.expires_at = now + (tokens.expires_in || 3600); // fallback 1h if missing
  localStorage.setItem(tokenStorageKey, JSON.stringify(tokens));
  localStorage.removeItem(pkceVerifierKey);

  // Clean the URL (remove ?code=... and state if present)
  try {
    window.history.replaceState({}, document.title, window.location.pathname);
  } catch (e) { /* ignore */ }

  return tokens;
}

// --- Get tokens from storage (no refresh token flow) ---
function getStoredTokens() {
  const raw = localStorage.getItem(tokenStorageKey);
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch (e) {
    localStorage.removeItem(tokenStorageKey);
    return null;
  }
}

// --- getAuthToken exported to app.js: returns token or forces login ---
async function getAuthToken() {
  const tokens = getStoredTokens();
  const now = Math.floor(Date.now() / 1000);

  if (tokens && tokens.expires_at && tokens.expires_at > now + 60) {
    return tokens.access_token || tokens.id_token;
  }

  // expired or missing => clear and redirect to login (no refresh flow)
  localStorage.removeItem(tokenStorageKey);
  // If we are currently processing a token exchange, don't immediately redirect.
  // But safe default: redirect now.
  redirectToLogin();
  return null;
}

// --- Main init: handle callback with ?code=... OR ensure logged-in ---
(async function initAuth() {
  const params = new URLSearchParams(window.location.search);
  const code = params.get("code");

  if (code) {
    const tokens = await exchangeCodeForTokens(code);
    if (tokens) {
      showApp(); // reveal your UI
      return;
    } else {
      // token exchange failed — send to login
      redirectToLogin();
      return;
    }
  }

  const tokens = getStoredTokens();
  if (!tokens || !tokens.id_token) {
    // No tokens stored — kick to login
    redirectToLogin();
  } else {
    // valid-looking token: show app (note: expiry check is in getAuthToken)
    showApp();
  }
})();

// --- Expose signOut (global) so index.html can call signOut() on button click ---
function signOut() {
  redirectToLogout();
}

// Utility: reveal app UI
function showApp() {
  const el = document.getElementById("auth-section");
  if (el) el.classList.remove("hidden");
}

// --- make functions available globally if needed ---
window.getAuthToken = getAuthToken;
window.signOut = signOut;
window.redirectToLogin = redirectToLogin;

